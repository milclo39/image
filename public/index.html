<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>miclobox</title>
    <link rel="icon" href="icon.png">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            touch-action: none;
            background: #333;
            font-family: sans-serif;
            user-select: none;
        }
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
        }
        #bgCanvas { z-index: 0; background: white; }
        #drawCanvas { z-index: 1; background: transparent; }
        
        /* --- „Éú„Çø„É≥ÂÖ±ÈÄö„Çπ„Çø„Ç§„É´ --- */
        button {
            width: 44px;
            height: 44px;
            font-size: 20px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            outline: none;
        }
        button:active { transform: scale(0.92); }

        /* „ÉÑ„Éº„É´ÈÅ∏ÊäûÁä∂ÊÖã */
        button.active-tool {
            background: #3b82f6; color: white;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        button.camera-active {
            background: #10b981; color: white;
        }

        /* --- „É°„Ç§„É≥Êìç‰Ωú„Éë„Éç„É´ --- */
        .controls {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 100;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* --- Ë®≠ÂÆö„Éë„Éç„É´ --- */
        .pen-settings {
            position: fixed;
            top: 70px;
            left: 15px;
            z-index: 99;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            display: none;
            flex-direction: column;
            gap: 12px;
            width: fit-content;
        }
        .pen-settings.show { display: flex; }
        
        .setting-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        .setting-group:not(:last-child) {
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        /* --- Ëâ≤„ÉªÂ§™„Åï„ÉªÈÄèÈÅé„Éú„Çø„É≥ --- */
        .color-btn {
            width: 28px; height: 28px; border-radius: 50%; padding: 0; box-shadow: none;
            border: 2px solid transparent;
        }
        .color-btn.selected {
            border-color: #555; transform: scale(1.15); box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .size-btn {
            width: 36px; height: 36px; background: transparent; box-shadow: none; border: 1px solid #eee;
        }
        .size-btn.selected { background: #eef2ff; border-color: #3b82f6; }
        .dot { background: #333; border-radius: 50%; display: block; }
        .opacity-btn {
            width: auto; padding: 0 8px; font-size: 12px; font-weight: bold; height: 32px;
            background: white; border: 1px solid #ddd; color: #666;
        }
        .opacity-btn.selected { background: #3b82f6; color: white; border-color: #3b82f6; }

        /* --- Èå≤Áîª„ÉªÊíÆÂΩ±Áî®„Éê„Éº --- */
        .media-controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 25px;
        }
        #snap-btn, #record-btn {
            width: 64px; height: 64px; border-radius: 50%; font-size: 26px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        #record-btn .icon {
            width: 26px; height: 26px; background: #ef4444; border-radius: 50%; transition: all 0.3s;
        }
        #record-btn.recording { border: 4px solid rgba(239,68,68,0.3); background: white; }
        #record-btn.recording .icon { border-radius: 4px; transform: scale(0.6); }

    </style>
</head>
<body>

<div class="controls">
    <button id="camera-btn" title="„Ç´„É°„É©Ëµ∑Âãï/ÂÅúÊ≠¢">üì∑</button>
    <button id="pen-tool-btn" class="active-tool" title="„Éö„É≥">‚úèÔ∏è</button>
    <button id="settings-toggle-btn" title="„Éö„É≥Ë®≠ÂÆö">üé®</button>
    <button id="eraser-btn" title="Ê∂à„Åó„Ç¥„É†">üßº</button>
    <button id="undo-btn" title="ÂÖÉ„Å´Êàª„Åô">‚Ü©Ô∏è</button>
    <button id="clear-btn" title="ÂÖ®Ê∂àÂéª">üóëÔ∏è</button>
</div>

<div id="pen-settings" class="pen-settings">
    <div class="setting-group" id="color-options"></div>
    <div class="setting-group">
        <button class="size-btn selected" data-size="5" title="Á¥∞„ÅÑ"><span class="dot" style="width:6px; height:6px;"></span></button>
        <button class="size-btn" data-size="10" title="ÊôÆÈÄö"><span class="dot" style="width:12px; height:12px;"></span></button>
        <button class="size-btn" data-size="20" title="Â§™„ÅÑ"><span class="dot" style="width:18px; height:18px;"></span></button>
        <button class="size-btn" data-size="40" title="Ê•µÂ§™"><span class="dot" style="width:24px; height:24px;"></span></button>
    </div>
    <div class="setting-group">
        <button class="opacity-btn selected" data-alpha="1.0">100%</button>
        <button class="opacity-btn" data-alpha="0.75">75%</button>
        <button class="opacity-btn" data-alpha="0.5">50%</button>
        <button class="opacity-btn" data-alpha="0.25">25%</button>
    </div>
</div>

<div class="media-controls">
    <button id="snap-btn" title="ÁîªÂÉè„Çí‰øùÂ≠ò">üì∏</button>
    <button id="record-btn" title="Èå≤ÁîªÈñãÂßã/ÂÅúÊ≠¢"><div class="icon"></div></button>
</div>

<div id="canvas-container">
    <canvas id="bgCanvas"></canvas>
    <canvas id="drawCanvas"></canvas>
</div>

<video id="video-feed" playsinline style="display:none;"></video>

<script>
    const STORAGE_KEY = 'ar_drawing_data_v4'; 
    const colors = [
        { code: '#000000' }, { code: '#FFFFFF' },
        { code: '#EF4444' }, { code: '#F97316' },
        { code: '#EAB308' }, { code: '#22C55E' },
        { code: '#3B82F6' }, { code: '#A855F7' }
    ];

    let state = {
        tool: 'pen',
        hexColor: '#000000',
        size: 5,
        alpha: 1.0
    };

    let activePointers = new Map();
    let paths = [];
    let isCameraRunning = false;
    let videoStream = null;
    let animationId = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;

    const drawCanvas = document.getElementById('drawCanvas');
    const bgCanvas = document.getElementById('bgCanvas');
    const drawCtx = drawCanvas.getContext('2d');
    const bgCtx = bgCanvas.getContext('2d');
    const recCanvas = document.createElement('canvas');
    const recCtx = recCanvas.getContext('2d');
    const video = document.getElementById('video-feed');
    const penSettingsPanel = document.getElementById('pen-settings');
    
    function init() {
        resize();
        window.addEventListener('resize', resize);
        createColorButtons();
        setupEventListeners();
        loadFromStorage();
        bgCtx.fillStyle = 'white';
        bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
    }

    function resize() {
        const w = window.innerWidth, h = window.innerHeight;
        drawCanvas.width = w; drawCanvas.height = h;
        bgCanvas.width = w; bgCanvas.height = h;
        recCanvas.width = w; recCanvas.height = h;
        redrawLines();
        if (!isCameraRunning) {
            bgCtx.fillStyle = 'white';
            bgCtx.fillRect(0, 0, w, h);
        }
    }

    function createColorButtons() {
        const container = document.getElementById('color-options');
        colors.forEach(c => {
            const btn = document.createElement('button');
            btn.className = 'color-btn';
            btn.style.backgroundColor = c.code;
            if (c.code === '#FFFFFF') btn.style.border = '1px solid #ccc';
            if (c.code === state.hexColor) btn.classList.add('selected');
            btn.onclick = () => {
                state.hexColor = c.code;
                updateUISelection('.color-btn', btn);
                switchToPen();
            };
            container.appendChild(btn);
        });
    }

    function setupEventListeners() {
        document.getElementById('pen-tool-btn').onclick = switchToPen;
        document.getElementById('eraser-btn').onclick = switchToEraser;
        document.getElementById('settings-toggle-btn').onclick = (e) => {
            e.stopPropagation();
            penSettingsPanel.classList.toggle('show');
        };
        document.querySelectorAll('.size-btn').forEach(btn => {
            btn.onclick = () => {
                state.size = parseInt(btn.dataset.size);
                updateUISelection('.size-btn', btn);
            };
        });
        document.querySelectorAll('.opacity-btn').forEach(btn => {
            btn.onclick = () => {
                state.alpha = parseFloat(btn.dataset.alpha);
                updateUISelection('.opacity-btn', btn);
            };
        });
        document.getElementById('undo-btn').onclick = undo;
        document.getElementById('clear-btn').onclick = clearAll;
        document.getElementById('camera-btn').onclick = toggleCamera;
        document.getElementById('snap-btn').onclick = takeSnapshot;
        document.getElementById('record-btn').onclick = toggleRecording;

        drawCanvas.addEventListener('pointerdown', handlePointerDown);
        drawCanvas.addEventListener('pointermove', handlePointerMove);
        drawCanvas.addEventListener('pointerup', handlePointerUp);
        drawCanvas.addEventListener('pointercancel', handlePointerUp);
    }

    function updateUISelection(selector, activeBtn) {
        document.querySelectorAll(selector).forEach(b => b.classList.remove('selected'));
        activeBtn.classList.add('selected');
    }

    function switchToPen() {
        state.tool = 'pen';
        document.getElementById('pen-tool-btn').classList.add('active-tool');
        document.getElementById('eraser-btn').classList.remove('active-tool');
        penSettingsPanel.classList.add('show');
    }

    function switchToEraser() {
        state.tool = 'eraser';
        document.getElementById('pen-tool-btn').classList.remove('active-tool');
        document.getElementById('eraser-btn').classList.add('active-tool');
        penSettingsPanel.classList.remove('show');
    }

    function getRgbaColor(hex, alpha) {
        const r = parseInt(hex.substring(1, 3), 16);
        const g = parseInt(hex.substring(3, 5), 16);
        const b = parseInt(hex.substring(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function redrawLines() {
        drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        drawCtx.lineCap = 'round';
        drawCtx.lineJoin = 'round';
        paths.forEach(path => drawPath(path));
        activePointers.forEach(path => drawPath(path));
    }

    // ‚òÖ‚òÖ‚òÖ „Çπ„É†„Éº„Ç∏„É≥„Ç∞Âá¶ÁêÜ„ÅÆÂÆüË£ÖÁÆáÊâÄ ‚òÖ‚òÖ‚òÖ
    function drawPath(path) {
        const p = path.points;
        if (p.length < 1) return;

        drawCtx.save();
        drawCtx.lineWidth = path.width;
        
        if (path.tool === 'eraser') {
            drawCtx.globalCompositeOperation = 'destination-out';
        } else {
            drawCtx.globalCompositeOperation = 'source-over';
            drawCtx.strokeStyle = path.color;
        }

        drawCtx.beginPath();

        if (p.length === 1) {
            // ÁÇπ„Åå1„Å§„ÅÆÂ†¥Âêà„ÅØÂÜÜ„ÇíÊèèÁîª
            drawCtx.arc(p[0].x, p[0].y, path.width / 2, 0, Math.PI * 2);
            if (path.tool !== 'eraser') drawCtx.fillStyle = path.color;
            drawCtx.fill();
        } else {
            // Êªë„Çâ„Åã„Å™Êõ≤Á∑öÊèèÁîª„É≠„Ç∏„ÉÉ„ÇØ
            drawCtx.moveTo(p[0].x, p[0].y);
            
            // ÁÇπ„Åå3„Å§Êú™Ê∫Ä„Å™„ÇâÁõ¥Á∑ö
            if (p.length < 3) {
                for (let i = 1; i < p.length; i++) {
                    drawCtx.lineTo(p[i].x, p[i].y);
                }
            } else {
                // quadraticCurveTo„Åß‰∏≠ÁÇπÂêåÂ£´„ÇíÁµê„Å∂
                let i;
                for (i = 1; i < p.length - 2; i++) {
                    const xc = (p[i].x + p[i + 1].x) / 2;
                    const yc = (p[i].y + p[i + 1].y) / 2;
                    // p[i]„ÇíÂà∂Âæ°ÁÇπ„Å®„Åó„ÄÅ‰∏≠ÁÇπ(xc, yc)„Å∏Á∑ö„ÇíÂºï„Åè
                    drawCtx.quadraticCurveTo(p[i].x, p[i].y, xc, yc);
                }
                // ÊúÄÂæå„ÅÆ2ÁÇπ„ÅØÊõ≤Á∑ö„ÅßÁµê„Å≥„Åç„Çã
                drawCtx.quadraticCurveTo(p[i].x, p[i].y, p[i + 1].x, p[i + 1].y);
            }
            drawCtx.stroke();
        }
        drawCtx.restore();
    }

    // --- Pointer Events ---
    function handlePointerDown(e) {
        e.preventDefault();
        penSettingsPanel.classList.remove('show');

        const drawColor = getRgbaColor(state.hexColor, state.alpha);
        const newPath = {
            id: e.pointerId,
            points: [{ x: e.clientX, y: e.clientY }],
            tool: state.tool,
            color: drawColor,
            width: state.tool === 'eraser' ? 25 : state.size
        };
        activePointers.set(e.pointerId, newPath);
        drawCanvas.setPointerCapture(e.pointerId);
        redrawLines();
    }

    function handlePointerMove(e) {
        if (!activePointers.has(e.pointerId)) return;
        const path = activePointers.get(e.pointerId);
        path.points.push({ x: e.clientX, y: e.clientY });
        redrawLines();
    }

    function handlePointerUp(e) {
        if (activePointers.has(e.pointerId)) {
            const path = activePointers.get(e.pointerId);
            paths.push(path);
            activePointers.delete(e.pointerId);
            drawCanvas.releasePointerCapture(e.pointerId);
            redrawLines();
            saveToStorage();
        }
    }

    function undo() {
        if (paths.length > 0) {
            paths.pop();
            redrawLines();
            saveToStorage();
        }
    }
    function clearAll() {
        if (confirm('„Åô„Åπ„Å¶Ê∂àÂéª„Åó„Åæ„Åô„ÅãÔºü')) {
            paths = [];
            redrawLines();
            saveToStorage();
        }
    }
    function saveToStorage() {
        try { localStorage.setItem(STORAGE_KEY, JSON.stringify(paths)); } catch(e){}
    }
    function loadFromStorage() {
        const json = localStorage.getItem(STORAGE_KEY);
        if (json) { try { paths = JSON.parse(json); redrawLines(); } catch(e){} }
    }

    // „Ç´„É°„É©„ÉªÈå≤ÁîªÈñ¢ÈÄ£
    async function toggleCamera() {
        if (isCameraRunning) stopCamera();
        else await startCamera();
    }
    async function startCamera() {
        try {
            const constraints = { video: { facingMode: 'environment' }, audio: false };
            videoStream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = videoStream;
            await video.play();
            isCameraRunning = true;
            document.getElementById('camera-btn').classList.add('camera-active');
            renderCameraLoop();
        } catch (err) { alert('Camera Error: ' + err.message); }
    }
    function stopCamera() {
        if (videoStream) videoStream.getTracks().forEach(t => t.stop());
        cancelAnimationFrame(animationId);
        video.srcObject = null;
        isCameraRunning = false;
        document.getElementById('camera-btn').classList.remove('camera-active');
        bgCtx.fillStyle = 'white';
        bgCtx.fillRect(0,0, bgCanvas.width, bgCanvas.height);
    }
    function renderCameraLoop() {
        if (!isCameraRunning) return;
        const w = bgCanvas.width, h = bgCanvas.height;
        const vW = video.videoWidth, vH = video.videoHeight;
        const scale = Math.max(w / vW, h / vH);
        const dW = vW * scale, dH = vH * scale;
        bgCtx.drawImage(video, (w - dW)/2, (h - dH)/2, dW, dH);
        if (isRecording) {
            recCtx.drawImage(bgCanvas, 0, 0);
            recCtx.drawImage(drawCanvas, 0, 0);
        }
        animationId = requestAnimationFrame(renderCameraLoop);
    }
    function takeSnapshot() {
        const tCanvas = document.createElement('canvas');
        tCanvas.width = drawCanvas.width; tCanvas.height = drawCanvas.height;
        const tCtx = tCanvas.getContext('2d');
        tCtx.drawImage(bgCanvas, 0, 0);
        tCtx.drawImage(drawCanvas, 0, 0);
        const link = document.createElement('a');
        link.download = `drawing-${Date.now()}.png`;
        link.href = tCanvas.toDataURL('image/png');
        link.click();
    }
    function toggleRecording() { isRecording ? stopRecording() : startRecording(); }
    function startRecording() {
        recordedChunks = [];
        const stream = recCanvas.captureStream(30);
        try { mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); }
        catch (e) { mediaRecorder = new MediaRecorder(stream); }
        mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `video-${Date.now()}.webm`;
            a.click();
            window.URL.revokeObjectURL(url);
        };
        mediaRecorder.start();
        isRecording = true;
        document.getElementById('record-btn').classList.add('recording');
        if (!isCameraRunning) loopRec();
    }
    function stopRecording() {
        if (mediaRecorder) mediaRecorder.stop();
        isRecording = false;
        document.getElementById('record-btn').classList.remove('recording');
    }
    function loopRec() {
        if (!isRecording || isCameraRunning) return;
        recCtx.fillStyle = 'white';
        recCtx.fillRect(0,0,recCanvas.width,recCanvas.height);
        recCtx.drawImage(drawCanvas,0,0);
        requestAnimationFrame(loopRec);
    }

    init();
</script>
</body>
</html>